# Standard 'split()' with an additional check for a 'null' string
def split_checkfornull($string_to_split; $delimiter):
    if 
        ($string_to_split | length) > 0
    then
        $string_to_split | split($delimiter)
    else
        null
    end
;

# Standard 'fromdate' with an additional check for a 'null' string
def fromdate_checkfornull($passed_in_date):
    if
        ($passed_in_date | length) > 0
    then
        $passed_in_date | fromdate
    else
        null
    end
;

# Convert incoming JSON to a standard IO format for building transforms.
# The original content is added to the output in the "original_message" field.
# This function also contains an object for use in building subrules
def get_io_format:
    {
        "input": .,
        "metadata":{
            "subrule":{}
        },
        "output": {
            "original_message": . | tojson
        }
    }
;

# augmented_io_format sets up a standard IO format for an incoming log after transformation.
# The input corresponds to the "original_message" field for use in building/augmenting the output.
def augmented_io_format:
    {
        "input": .original_message | fromjson,
        "output": .
    }
;

# If the subrule name is defined, put it into tag1
def assign_subrule:
    if
        .metadata.subrule.name
    then
        .output.tag1 = .metadata.subrule.name
    else
        .
    end
;

# add_field adds a key-value pair to the metadata objects generated by get_io_format
# Takes an input and output filter as parameters
# Capable of adding data to any of the objects in the metadata JSON (input, output, subrule, transform_path, etc)
def add_field($input_field; output_field):

    #Check for pipe character
    ($input_field | tojson) as $input_field_string
    
    (($input_field_string | contains("|")) or ($input_field_string | contains("\\n")) | not ) as $nobadchars

    if
        $input_field and $nobadchars
    then
        output_field = $input_field
    elif 
        $input_field and ($nobadchars | not)
    then
        #remove pipes from input_field
        ($input_field_string | split("|") | join("-")) as $input_field_nopipes |
        ($input_field_nopipes | split("\\n") | join(" ")) as $input_field_nobadchars |
        output_field = ($input_field_nobadchars | fromjson)
    else
        .
    end
;

# convert_to_kilobytes : Converts the bytes into Kilobytes
def convert_to_kilobytes($bytes):
    if
        $bytes | type == "number"
    then
        $bytes / 1000
    else
        null
    end
;

# fan_logs_from_array will fan out the pipeline, returning n values
#  where n is the number of records in the log message. If there are no records
#  the input is returned unchanged
def fan_logs_from_array($log_msg_field):
    if $log_msg_field then
        if ($log_msg_field | length) > 0 then
            # flatten our records into one message each
            $log_msg_field[]
        else
            .
        end
    else
        .
    end
;
# convert_to_nanosecond : Convert the timestamp value according the code provided to nanoseconds
def convert_to_nanosecond($timestamp; $code):
    if
        (($code | type == "string") and ($timestamp | type == "number"))
    then
        if
            ($code == "usec")
        then
            $timestamp * 1000
        elif
            ($code == "msec" or $code == "ms")
        then
            $timestamp * 1000000
        elif
            ($code == "sec" or $code == "s")
        then
            $timestamp * 1000000000
        else
            .
        end
    else
        null
    end
;

# is_ipv4 will attempt to determine if the input is an IPv4 address
def check_ipv4($value):
    if $value | type != "string" then
        false
    else
        $value | split(".") as $SPLITS |
        if $SPLITS | length != 4 then
            false
        else
            # Any that aren't numbers will not return an element in results
            $SPLITS | map(. | tonumber?) as $RESULTS |
            if
                ($SPLITS | length) == ($RESULTS | length)
            then
                $value
            else
                null
            end
        end
    end
;